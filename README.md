# Secure_code_test
Security code review test task AppSecCloudCamp

## 1. Вопросы для разогрева

1. Расскажите, с какими задачами в направлении безопасной разработки вы сталкивались? 

    1.1 
    Настройка HTTPS протокола при деплое веб-приложения на сервер. В текущих реалиях 
  обязательно использовать HTTPS, а не HTTP протокол, что позволяет надежно 
  зашифровать канал передачи данных между клиентом и сервером.

    1.2 
    Разработка аутентификации с помощью JWT. Было важно использовать актуальный метод
  шифрования(например, SHA-256). Также желательно настроить автообновление JWT библиотеки
  до последней версии и реализовать возможность двухфакторной аутентификации.

    1.3 Изменение имени корневого пользователя (root) на Ubuntu-сервере с целью повышения
  безопасности. Такая операция снижает вероятность успешных атак методом брутфорса. 
  Однако процесс изменения имени root может быть сложным, так как вне самой системы 
  сервера могут существовать скрипты(например, которые используют подключение к базе 
  данных сервера) и они могут зависеть от логина корневого пользователя для установления соединения.

2. Если вам приходилось проводить security code review или моделирование угроз, расскажите, как это было? 
    
    В одном из своих проектов обнаружил XSS во входном поле формы сайта. Если конкретно, пользовательский
  ввод был недостаточно фильтрован(Усовершенствовал REGEXP для лучшей фильтрации) и настроил экранирование
  символов пароля.

3. Если у вас был опыт поиска уязвимостей, расскажите, как это было? 

    Думаю, этот вопрос в некоторой степени раскрывается предыдущими. Ещё удалось вспомнить обнаружение 
  чувствительных данных в очереди GET-запроса(логин пользователя), причем обнаружил в строке браузера,
  случайно, можно сказать:)

4. Почему вы хотите участвовать в стажировке?

    Считаю, что за счет прокачки в области secure code и облачных сервисов я смогу стать наиболее целостным 
  специалистом, и благодаря этому опыту смогу принести существенную пользу как компании Cloud.ru, так и сообществу
  разработчиков в целом.
---

## 2. Security code review

### Часть 1. Security code review: GO

Требуется провести анализ кода на GO с точки зрения безопасности и подготовить отчет по следующим пунктам:
 - Какие уязвимости присутствуют в этом фрагменте кода?
 - Указать строки, в которых присутствуют уязвимости.
 - К каким последствиям может привести эксплуатация найденных уязвимостей злоумышленником?
 - Описать способы исправления уязвимостей.
 - Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.

```
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "github.com/go-sql-driver/mysql"
)

var db *sql.DB
var err error

func initDB() {
    db, err = sql.Open("mysql", "user:password@/dbname")
    if err != nil {
        log.Fatal(err)
    }

err = db.Ping()
if err != nil {
    log.Fatal(err)
    }
}

func searchHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != "GET" {
        http.Error(w, "Method is not supported.", http.StatusNotFound)
        return
    }

searchQuery := r.URL.Query().Get("query")
if searchQuery == "" {
    http.Error(w, "Query parameter is missing", http.StatusBadRequest)
    return
}

query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)
rows, err := db.Query(query)
if err != nil {
    http.Error(w, "Query failed", http.StatusInternalServerError)
    log.Println(err)
    return
}
defer rows.Close()

var products []string
for rows.Next() {
    var name string
    err := rows.Scan(&name)
    if err != nil {
        log.Fatal(err)
    }
    products = append(products, name)
}

fmt.Fprintf(w, "Found products: %v\n", products)
}

func main() {
    initDB()
    defer db.Close()

http.HandleFunc("/search", searchHandler)
fmt.Println("Server is running")
log.Fatal(http.ListenAndServe(":8080", nil))
}
```

 -------------------------Ответ---------------------------

 Мне удалось обнаружить несколько уязвимостей в коде выше:

 1.SQL-инъекции
  Уязвимость SQL-инъекции возникает из-за того, что строка 'searchQuery'
  напрямую вставляется в SQL запрос без проверок.

  Уязвимость обнаружена в следующей строке:
  query := fmt.Sprintf("SELECT * FROM products WHERE name LIKE '%%%s%%'", searchQuery)

  Злоумышленник получает возможность выполнять произвольные SQL запросы к базе
  данных, что может привести к изменению/удалению данных или утечке информации.

  Основной способ исправления - использование параметризованных запросов для защиты
  от инъекций. В данном случае можно заменить строку запроса приблизительно следующим
  образом: query := "SELECT * FROM products WHERE name LIKE ?" и передавать searchQuery 
  как аргумент функции db.Query.

2.Возможность утечки информации
    В случае ошибки выполнения запроса, содержимым ошибки может воспользоваться
  злоумышленник для атаки.

  Уязвимость обнаружена в следующей строке:
  log.Println(err)

  Злоумышленник может использовать информацию об ошибках для определения структуры
  базы данных и другой чувствительной информации.

  Вместо вывода ошибки напрямую, можно использовать общие сообщения об ошибке 
  без раскрытия конкретных деталей.

### Часть 2: Security code review: Python

Требуется определить тип уязвимости в примерах кода на Python и ответить на следующие вопросы:
 - Указать строки, в которых присутствуют уязвимости.
 - К каким последствиям может привести эксплуатация данных уязвимостей злоумышленником?
 - Описать способы исправления уязвимостей.
 - Если уязвимость можно исправить несколькими способами, необходимо перечислить их, выбрать лучший по вашему мнению и аргументировать свой выбор.


**Пример №2.1**
```
from flask import Flask, request
from jinja2 import Template

app = Flask(name)

@app.route("/page")
def page():
    name = request.values.get('name')
    age = request.values.get('age', 'unknown')
    output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
return output

if name == "main":
    app.run(debug=True)
```
-------------------------Ответ----------------------------------------

  Возможность использования XSS, обхода аутентификации, инъекции кода
  Уязвимость возникает из-за того, что шаблоны модуля Jinja2 в данном случае не экранированы
  и входные данные (переменные name и age) никак не фильтруются.

  Уязвимость обнаружена в следующей строке:
  
  ```
  output = Template('Hello ' + name + '! Your age is ' + age + '.').render()
  ```

  Злоумышленник может использовать уязвимость для внедрения произвольного кода в 
  отображаемую страницу. Это может привести к XSS, обходу аутентификации, инъекции кода.

  В данном случае придумал 2 способа исправления уязвимости:
  Первый способ - использовать безопасный метод render_string вместо render и правильно
  экранировать входные данные (воспользуемся функцией escape из библиотеки flask):
  
  ```
  from flask import escape
  output = Template('Hello ' + escape(name) + '! Your age is ' + escape(age) + '.').render()
  ```
  Второй способ - использовать передачу переменных через функцию render_template из flask:
  
  ```
  from flask import render_template
  return render_template('page.html', name=name, age=age)
  ```
  Думаю, что лучшим вариантом будет использование render_template, т.к. flask автоматически
  экранирует данные, переданные через данную функцию, что делает код более безопасным, а его
  лаконичность способствует лучшей читаемости.
 
**Пример №2.2**
```
from flask import Flask, request
import subprocess

app = Flask(name)

@app.route("/dns")
def dns_lookup():
    hostname = request.values.get('hostname')
    cmd = 'nslookup ' + hostname
    output = subprocess.check_output(cmd, shell=True, text=True)
return output
if name == "main":
    app.run(debug=True)
```
-------------------------Ответ-----------------------------------------------------

  В данном примере присутствует уязвимость, связанная с выполнением внешних команд 
  через модуль subprocess без проверки или фильтрации пользовательского ввода.
  Переменная hostname не проверяется на содержание нежелательных символов или команд,
  которые могут быть выполнены системой.

  Уязвимость обнаружена в следующих строках:
  ```
  cmd = 'nslookup ' + hostname
  output = subprocess.check_output(cmd, shell=True, text=True)
  ```
  Злоумышленник может использовать эту уязвимость для выполнения произвольных команд 
  на сервере, на котором работает приложение Flask. Это может привести к утечке конфиденциальной 
  информации, изменению настроек сервера и т.д..

  Для этого фрагмента кода есть 2 способа исправления уязвимости:
  Первый - использовать более безопасные альтернативы для выполнения DNS-запросов, 
  например, использование специальной библиотеки socket:
  
  ```
  import socket

  hostname = request.values.get('hostname')
  try:
    ip_address = socket.gethostbyname(hostname)
    output = f'IP Address for {hostname} is {ip_address}'
  except socket.gaierror:
    output = f'Cannot resolve {hostname}'
  ```
  Второй способ - если использование subprocess необходимо, то входные данные должны быть 
  подготовлены перед использованием:
  
  ```
  import socket
  
  hostname = request.values.get('hostname')
  cmd = ['nslookup', hostname]
  output = subprocess.check_output(cmd, text=True)
  ```
  В данном случае использование библиотечной функции socket.gethostbyname() кажется более
  безопасным вариантом, поскольку отсутствует вызов внешних команд, соответственно, 
  предотвращается возможность выполнения произвольного кода на сервере.


## 3. Моделировани угроз

Изучите диаграмму потоков данных (Data Flow Diagram, DFD) сервиса, обеспечивающего отправку информации в Telegram и Slack:

![DFD](https://github.com/appseccloudcamp/test-assignment/blob/main/test-dfd.png)

Краткое описание компонентов сервиса:
 - **User** - авторизованный пользователь системы. Может настраивать отправку уведомлений и загружать изображения для дальнейшего использования при отправке уведомлений;
 - **Microfront** - микрофронт, которые позволяет взаимодействовать с сервисом отправки информации;
 - **Backend application** - набор микросервисов реализующих бизнес-логику приложения и обеспечивающих взаимодействие со всеми внешними сервисами;
 - **Auth** - сервис отвечающий за аутентификацию и авторизацию клиентов сервиса отправки информации;
 - **S3** - объектное хранилище, предназначенное для хранения статического контента сервиса отправки информации;
 - **PostgreSQL** - база данных, предназначенная для хранения пользовательских конфигураций сервиса отправки информации.    

Проанализируйте диаграмму потоков данных приложения и ответьте на следующий вопросы:
 - Расскажите, какие потенциальные проблемы безопасности существуют для данного сервиса?
 - Расскажите, к каким последствиям может привести эксплуатация проблем, найденных вами?
 - Расскажите, какие способы исправления уязвимостей и смягчения рисков вы можете предложить по отмеченным вами проблемам безопасности?
 - Напишите список уточняющих вопросов, которые вы бы задали разработчикам данного сервиса?

 -------------------------Ответ----------------------------------------

  Потенциальные проблемы безопасности:

  Недостаточная защита данных в пути: необходимо убедиться, что все обмены
  данными между компонентами сервиса защищены протоколом HTTPS.

  Недостаточная защита данных в покое: база данных PostgreSQL и объектное хранилище S3 
  должны быть хорошо защищены с использованием механизмов шифрования данных и управления доступом.

  Недостаточная защита пользовательских данных: сервис Auth должен надежно хранить 
  и обрабатывать данные пользователей, предотвращая брутфорс атаки.

  Недостаточная обработка пользовательского ввода: все входные данные, поступающие от пользователей,
  должны быть правильно проверены и фильтрованы, чтобы предотвратить атаки вроде инъекций.

  Возможные последствия эксплуатации проблем:

  Утечка конфиденциальных данных пользователей.
  Подмена или подделка уведомлений, отправляемых на платформы Telegram и Slack.
  Отказ сервиса из-за атаки, включая атаки на отказ в обслуживании (DDoS).
  Снижение производительности серверов путем внедрения незаметных майнеров.
  Размещение компроментирующей информации на микрофронтенд сервисе.
  
  Способы исправления уязвимостей и смягчения рисков:

  Внедрение обязательного использования HTTPS для всех соединений между компонентами сервиса, между сервисом и внешними платформами.
  Внедрение механизмов шифрования данных для хранения чувствительной информации в базе данных и объектном хранилище.
  Реализация строгих политик безопасности для управления доступом к ресурсам сервиса и обеспечения безопасности аутентификации.
  Внедрение механизмов фильтрации и валидации пользовательского ввода для предотвращения атак вроде инъекций.

  Уточняющие вопросы для разработчиков:

  Как реализована система авторизации в сервисе?
  Как обрабатывается и хранится пользовательский ввод перед сохранением в базу данных или отправкой на внешние платформы?
  Как обеспечивается безопасность хранилища S3 и базы данных?
  Какие меры безопасности принимаются для защиты сервиса от DDoS атак?
  Какие меры безопасности принимаются для защиты от брутфорс атак при авторизации?
  Есть ли правила в линтере проекта, используемые для минимизации уязвимостей?
